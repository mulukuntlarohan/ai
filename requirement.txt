### agent.py ###
from knowledge_base import ResolutionEngine, KBInitializer, KBUpdater

class Agent:
    def __init__(self, wumpus_world, resolution_engine):
        self.wumpus_world = wumpus_world
        self.resolution_engine = resolution_engine
        self.position = (0, 0)
        self.has_gold = False
        self.is_alive = True
        self.visited = set()
        self.safe_cells = set()
        self.kb_updater = KBUpdater(self.resolution_engine)

    def perceive(self):
        return self.wumpus_world.get_percepts(self.position)

    def update_knowledge(self, percepts):
        # Update the knowledge base with the percepts received and infer new information.
        self.kb_updater.update_kb(percepts)
        self.visited.add(self.position)
        if not percepts['stench'] and not percepts['breeze']:
            self.safe_cells.add(self.position)

    def decide_action(self, percepts):
        # Use knowledge inferred to decide the next action.
        if self.has_gold:
            return "climb"
        if percepts['glitter']:
            self.has_gold = True
            return "grab"
        if percepts['stench']:
            return "avoid wumpus"
        if percepts['breeze']:
            return "avoid pit"
        return self.explore_safe_area()

    def explore_safe_area(self):
        # Use inferred safe cells to decide next move.
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            next_position = (self.position[0] + dx, self.position[1] + dy)
            if next_position not in self.visited and next_position in self.safe_cells:
                return "move", next_position
        return "move", (self.position[0] + 1, self.position[1])

    def move(self, action):
        if action == "climb":
            self.is_alive = False
        elif action == "grab":
            pass
        elif isinstance(action, tuple) and action[0] == "move":
            next_position = action[1]
            self.position = next_position
            self.wumpus_world.agent_pos = self.position

    def act(self):
        while self.is_alive:
            percepts = self.perceive()
            self.update_knowledge(percepts)
            action = self.decide_action(percepts)
            self.move(action)


### knowledge_base.py ###
class Clause:
    def __init__(self, literals):
        self.literals = set(literals)

    def __str__(self):
        return " ∨ ".join(sorted(self.literals))

    def is_complementary(self, other):
        for literal in self.literals:
            if f"¬{literal}" in other.literals or (literal[1:] if literal.startswith('¬') else f"¬{literal}") in other.literals:
                return True
        return False

    def resolve(self, other):
        new_literals = self.literals.union(other.literals)
        for literal in self.literals:
            if f"¬{literal}" in other.literals:
                new_literals.remove(literal)
                new_literals.remove(f"¬{literal}")
                break
        return Clause(new_literals)

class ResolutionEngine:
    def __init__(self):
        self.clauses = []

    def add_clause(self, clause):
        self.clauses.append(clause)

    def resolve(self):
        new_clauses = set()
        for i, clause1 in enumerate(self.clauses):
            for j, clause2 in enumerate(self.clauses):
                if i >= j:
                    continue
                if clause1.is_complementary(clause2):
                    resolvent = clause1.resolve(clause2)
                    if not self.is_tautology(resolvent):
                        new_clauses.add(resolvent)
        if new_clauses.difference(set(self.clauses)):
            self.clauses.extend(new_clauses)
            return True
        return False

    def is_tautology(self, clause):
        return any(literal in clause.literals and f'¬{literal}' in clause.literals for literal in clause.literals)

    def resolve_facts(self):
        inferred_facts = []
        while self.resolve():
            pass  # Continue resolution
        return inferred_facts

class KBInitializer:
    def __init__(self, resolution_engine):
        self.resolution_engine = resolution_engine
        self.initialize_kb()

    def initialize_kb(self):
        self.resolution_engine.add_clause(Clause(['stench', '¬WumpusNearby']))
        self.resolution_engine.add_clause(Clause(['¬stench', 'WumpusAway']))
        self.resolution_engine.add_clause(Clause(['breeze', '¬PitNearby']))
        self.resolution_engine.add_clause(Clause(['¬breeze', 'PitAway']))

class KBUpdater:
    def __init__(self, resolution_engine):
        self.resolution_engine = resolution_engine

    def update_kb(self, percepts):
        if percepts['stench']:
            self.resolution_engine.add_clause(Clause(['stench']))
        if percepts['breeze']:
            self.resolution_engine.add_clause(Clause(['breeze']))
        if percepts['glitter']:
            self.resolution_engine.add_clause(Clause(['gold']))

        while self.resolution_engine.resolve():
            pass  # Continue resolving until no new clauses are generated


### game.py ###
import pygame
import random
from knowledge_base import ResolutionEngine, KBInitializer, KBUpdater
from agent import Agent
from wumpus_world import WumpusWorld
from utils import Button

# Constants
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
GRID_CELL_SIZE = 100
FPS = 30

class Game:
    def __init__(self, config):
        self.grid_size = config['grid_size']
        self.num_pits = config['num_pits']
        self.wumpus_position = tuple(config['wumpus_position'])
        self.agent_position = tuple(config['agent_start_position'])
        self.gold_position = tuple(config['gold_position'])
        self.pits = self.generate_pits()

        # Initialize Wumpus World and Agent
        self.wumpus_world = WumpusWorld(self.grid_size, self.num_pits, self.wumpus_position, self.gold_position)
        self.resolution_engine = ResolutionEngine()
        self.knowledge_base = KBInitializer(self.resolution_engine)
        self.agent = Agent(self.wumpus_world, self.resolution_engine)
        self.kb_updater = KBUpdater(self.resolution_engine)

        # Pygame setup
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Wumpus World AI")
        self.clock = pygame.time.Clock()
        self.running = True
        self.game_over = False

        # Initialize buttons
        self.ai_button = Button(650, 50, 100, 40, "AI")
        self.place_pits_button = Button(650, 150, 100, 40, "Place Pits")

    def draw(self):
        self.screen.fill((255, 255, 255))
        for x in range(self.grid_size):
            for y in range(self.grid_size):
                pygame.draw.rect(self.screen, (200, 200, 200), (x * GRID_CELL_SIZE, y * GRID_CELL_SIZE, GRID_CELL_SIZE, GRID_CELL_SIZE), 1)
        self.draw_agent()
        self.draw_gold()
        self.draw_pits()
        self.draw_wumpus()
        self.draw_safe_cells()
        self.ai_button.draw(self.screen)
        self.place_pits_button.draw(self.screen)
        pygame.display.update()

    def draw_agent(self):
        pygame.draw.rect(self.screen, (0, 0, 255), (self.agent_position[0] * GRID_CELL_SIZE, self.agent_position[1] * GRID_CELL_SIZE, GRID_CELL_SIZE, GRID_CELL_SIZE))

    def draw_gold(self):
        pygame.draw.rect(self.screen, (255, 255, 0), (self.gold_position[0] * GRID_CELL_SIZE, self.gold_position[1] * GRID_CELL_SIZE, GRID_CELL_SIZE, GRID_CELL_SIZE))

    def draw_pits(self):
        for pit in self.pits:
            pygame.draw.rect(self.screen, (0, 0, 0), (pit[0] * GRID_CELL_SIZE, pit[1] * GRID_CELL_SIZE, GRID_CELL_SIZE, GRID_CELL_SIZE))

    def draw_wumpus(self):
        pygame.draw.rect(self.screen, (255, 0, 0), (self.wumpus_position[0] * GRID_CELL_SIZE, self.wumpus_position[1] * GRID_CELL_SIZE, GRID_CELL_SIZE, GRID_CELL_SIZE))

    def draw_safe_cells(self):
        for cell in self.agent.safe_cells:
            pygame.draw.rect(self.screen, (0, 255, 0), (cell[0] * GRID_CELL_SIZE, cell[1] * GRID_CELL_SIZE, GRID_CELL_SIZE, GRID_CELL_SIZE), 3)

if __name__ == "__main__":
    config = {
        "grid_size": 4,
        "num_pits": 2,
        "wumpus_position": [1, 1],
        "agent_start_position": [0, 0],
        "gold_position": [3, 3],
    }
    game = Game(config)
    game.run()


### wumpus_world.py ###
import random

class WumpusWorld:
    def __init__(self, size=4, num_pits=2, wumpus_pos=None, gold_pos=None):
        self.size = size
        self.grid = [[' ' for _ in range(size)] for _ in range(size)]
        self.agent_pos = (0, 0)
        self.wumpus_pos = wumpus_pos
        self.gold_pos = gold_pos
        self.pits = set()
        self.breeze_cells = set()
        self.stench_cells = set()
        self.visited = set()

        if not self.wumpus_pos:
            self.place_wumpus()
        if not self.gold_pos:
            self.place_gold()
        for _ in range(num_pits):
            self.place_pit()

    def place_wumpus(self, x=None, y=None):
        if x is None or y is None:
            x, y = self.get_random_position()
        if self.is_valid_position(x, y):
            self.wumpus_pos = (x, y)
            self.grid[x][y] = 'W'
            self.update_stench(x, y)

    def place_gold(self, x=None, y=None):
        if x is None or y is None:
            x, y = self.get_random_position()
        if self.is_valid_position(x, y):
            self.gold_pos = (x, y)
            self.grid[x][y] = 'G'

    def place_pit(self, x=None, y=None):
        if x is None or y is None:
            x, y = self.get_random_position()
        if self.is_valid_position(x, y):
            self.pits.add((x, y))
            self.grid[x][y] = 'P'
            self.update_breeze(x, y)

    def get_random_position(self):
        while True:
            x, y = random.randint(0, self.size - 1), random.randint(0, self.size - 1)
            if self.grid[x][y] == ' ' and (x, y) != self.agent_pos and (x, y) != self.wumpus_pos and (x, y) not in self.pits:
                return x, y

    def update_breeze(self, x, y):
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if self.is_valid_position(nx, ny):
                self.breeze_cells.add((nx, ny))

    def update_stench(self, x, y):
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if self.is_valid_position(nx, ny):
                self.stench_cells.add((nx, ny))

    def is_valid_position(self, x, y):
        return 0 <= x < self.size and 0 <= y < self.size

    def get_percepts(self, position):
        percepts = {
            'stench': position in self.stench_cells,
            'breeze': position in self.breeze_cells,
            'glitter': position == self.gold_pos,
            'bump': False
        }
        return percepts

    def move_agent(self, direction):
        x, y = self.agent_pos
        if direction == 'UP':
            new_pos = (x - 1, y)
        elif direction == 'DOWN':
            new_pos = (x + 1, y)
        elif direction == 'LEFT':
            new_pos = (x, y - 1)
        elif direction == 'RIGHT':
            new_pos = (x, y + 1)
        else:
            return {"error": "Invalid direction"}

        if self.is_valid_position(*new_pos):
            self.agent_pos = new_pos
            self.visited.add(self.agent_pos)
            percepts = self.get_percepts(new_pos)
            percepts['bump'] = False
        else:
            percepts = self.get_percepts((x, y))
            percepts['bump'] = True

        return percepts


### utils.py ###
import pygame

class Button:
    def __init__(self, x, y, width, height, text):
        self.rect = pygame.Rect(x, y, width, height)
        self.text = text
        self.font = None

    def draw(self, screen):
        if not self.font:
            self.font = pygame.font.Font('assets/fonts/game_font.ttf', 24)
        pygame.draw.rect(screen, (0, 128, 255), self.rect)
        text_surface = self.font.render(self.text, True, (255, 255, 255))
        screen.blit(
            text_surface,
            (self.rect.x + (self.rect.width - text_surface.get_width()) // 2,
             self.rect.y + (self.rect.height - text_surface.get_height()) // 2)
        )

    def is_clicked(self, mouse_pos):
        return self.rect.collidepoint(mouse_pos)
